import React, { useState, useEffect, useRef } from "react";

const CRYPTOS = ["BTC", "SOL", "LTC", "ETH"];
const INITIAL_BALANCE = 100;
const STOCKS = [
  { symbol: "ACME", name: "Acme Corp", basePrice: 50 },
  { symbol: "GME", name: "GameMart", basePrice: 120 },
  { symbol: "FLUX", name: "Flux Industries", basePrice: 30 },
  { symbol: "ZEN", name: "Zenith Ltd.", basePrice: 75 },
];

// Helper sound function (simple beep)
const playSound = (type) => {
  try {
    const ctx = new AudioContext();
    const oscillator = ctx.createOscillator();
    oscillator.type = type === "win" ? "triangle" : "sine";
    oscillator.frequency.setValueAtTime(type === "win" ? 880 : 440, ctx.currentTime);
    oscillator.connect(ctx.destination);
    oscillator.start();
    oscillator.stop(ctx.currentTime + 0.15);
  } catch (e) {
    // Audio not supported or blocked, fail silently
  }
};

export default function CryptoGamble() {
  // --- Balances stored in localStorage ---
  const [balances, setBalances] = useState(() => {
    const saved = localStorage.getItem("balances");
    if (saved) return JSON.parse(saved);
    let init = {};
    CRYPTOS.forEach((c) => (init[c] = INITIAL_BALANCE));
    return init;
  });

  const [selectedCrypto, setSelectedCrypto] = useState(CRYPTOS[0]);
  const [gameMessage, setGameMessage] = useState("");
  const [betAmount, setBetAmount] = useState(1);

  // --- Stock Market state ---
  const [stockPrices, setStockPrices] = useState(() =>
    STOCKS.reduce((acc, s) => {
      acc[s.symbol] = s.basePrice;
      return acc;
    }, {})
  );
  const [portfolio, setPortfolio] = useState(() => {
    const saved = localStorage.getItem("portfolio");
    return saved ? JSON.parse(saved) : {};
  });

  // --- Leaderboard (top portfolio value or winnings) ---
  const [leaderboard, setLeaderboard] = useState(() => {
    const saved = localStorage.getItem("leaderboard");
    return saved ? JSON.parse(saved) : [];
  });

  // --- Game states ---
  const [diceRoll, setDiceRoll] = useState(null);
  const [coinFlip, setCoinFlip] = useState(null); // "heads" or "tails"
  const [slotResult, setSlotResult] = useState(null);
  const [slotSpinning, setSlotSpinning] = useState(false);

  // --- Portfolio total value ---
  const portfolioValue = Object.entries(portfolio).reduce((total, [symbol, qty]) => {
    const price = stockPrices[symbol] || 0;
    return total + qty * price;
  }, 0);

  // --- Save balances and portfolio on changes ---
  useEffect(() => {
    localStorage.setItem("balances", JSON.stringify(balances));
  }, [balances]);

  useEffect(() => {
    localStorage.setItem("portfolio", JSON.stringify(portfolio));
  }, [portfolio]);

  useEffect(() => {
    localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
  }, [leaderboard]);

  // --- Stock price updates every 3 seconds ---
  useEffect(() => {
    const interval = setInterval(() => {
      setStockPrices((oldPrices) => {
        const newPrices = { ...oldPrices };
        STOCKS.forEach(({ symbol, basePrice }) => {
          const changePercent = (Math.random() - 0.5) * 0.1; // -5% to +5%
          let newPrice = newPrices[symbol] * (1 + changePercent);
          // Bound prices between 50% and 150% of base
          newPrice = Math.max(basePrice * 0.5, Math.min(basePrice * 1.5, newPrice));
          newPrices[symbol] = +newPrice.toFixed(2);
        });
        return newPrices;
      });
    }, 3000);
    return () => clearInterval(interval);
  }, []);

  // --- Utility: update balance for selected crypto ---
  function updateBalance(amount) {
    setBalances((bals) => {
      let newBal = Math.min(100, Math.max(0, bals[selectedCrypto] + amount));
      return { ...bals, [selectedCrypto]: +newBal.toFixed(2) };
    });
  }

  // --- Betting helper: check bet amount validity ---
  function validBet(amount) {
    return amount > 0 && amount <= balances[selectedCrypto];
  }

  // --- Game: Dice ---
  function playDice() {
    if (!validBet(betAmount)) {
      setGameMessage("Invalid bet amount!");
      return;
    }
    setGameMessage("");
    const roll = Math.floor(Math.random() * 6) + 1; // 1 to 6
    setDiceRoll(roll);
    updateBalance(-betAmount);
    // Win if roll > 3 (4,5,6)
    if (roll > 3) {
      const winAmount = betAmount * 2;
      updateBalance(winAmount);
      setGameMessage(`You rolled a ${roll} and won ${winAmount.toFixed(2)} ${selectedCrypto}!`);
      playSound("win");
      updateLeaderboard(winAmount);
    } else {
      setGameMessage(`You rolled a ${roll}. You lost ${betAmount.toFixed(2)} ${selectedCrypto}.`);
      playSound("lose");
    }
  }

  // --- Game: Coin Flip ---
  const [coinBet, setCoinBet] = useState("heads");
  function playCoinFlip() {
    if (!validBet(betAmount)) {
      setGameMessage("Invalid bet amount!");
      return;
    }
    setGameMessage("");
    const flip = Math.random() < 0.5 ? "heads" : "tails";
    setCoinFlip(flip);
    updateBalance(-betAmount);
    if (flip === coinBet) {
      const winAmount = betAmount * 2;
      updateBalance(winAmount);
      setGameMessage(`It was ${flip}. You won ${winAmount.toFixed(2)} ${selectedCrypto}!`);
      playSound("win");
      updateLeaderboard(winAmount);
    } else {
      setGameMessage(`It was ${flip}. You lost ${betAmount.toFixed(2)} ${selectedCrypto}.`);
      playSound("lose");
    }
  }

  // --- Game: Slot Machine ---
  const slotSymbols = ["🍒", "🍋", "🔔"];
  function playSlot() {
    if (slotSpinning) return; // Prevent spam
    if (!validBet(betAmount)) {
      setGameMessage("Invalid bet amount!");
      return;
    }
    setGameMessage("");
    setSlotSpinning(true);
    updateBalance(-betAmount);

    // Animate spinning for 1.5 seconds
    let spins = 0;
    const maxSpins = 15;
    const spinInterval = setInterval(() => {
      spins++;
      setSlotResult([
        slotSymbols[Math.floor(Math.random() * slotSymbols.length)],
        slotSymbols[Math.floor(Math.random() * slotSymbols.length)],
        slotSymbols[Math.floor(Math.random() * slotSymbols.length)],
      ]);
      if (spins >= maxSpins) {
        clearInterval(spinInterval);
        // Evaluate result
        const [s1, s2, s3] = slotResult || ["", "", ""];
        let winAmount = 0;
        if (s1 === s2 && s2 === s3) {
          // Jackpot x5
          winAmount = betAmount * 5;
        } else if (s1 === s2 || s2 === s3 || s1 === s3) {
          // Two match x2
          winAmount = betAmount * 2;
        }
        if (winAmount > 0) {
          updateBalance(winAmount);
          setGameMessage(`You won ${winAmount.toFixed(2)} ${selectedCrypto} on slots!`);
          playSound("win");
          updateLeaderboard(winAmount);
        } else {
          setGameMessage(`No win. You lost ${betAmount.toFixed(2)} ${selectedCrypto}.`);
          playSound("lose");
        }
        setSlotSpinning(false);
      }
    }, 100);
  }

  // --- Withdraw simulation ---
  function withdraw() {
    if (balances[selectedCrypto] === 0) {
      setGameMessage(`No balance to withdraw in ${selectedCrypto}.`);
      return;
    }
    setGameMessage(`Withdrawing ${balances[selectedCrypto].toFixed(2)} ${selectedCrypto}...`);
    // Simulate delay
    setTimeout(() => {
      setBalances((bals) => ({ ...bals, [selectedCrypto]: 0 }));
      setGameMessage(`Withdrawal successful! Your ${selectedCrypto} balance is now 0.`);
    }, 1500);
  }

  // --- Stock Market: buy shares ---
  function buyShares(symbol) {
    const price = stockPrices[symbol];
    const maxBuy = Math.floor(balances[selectedCrypto] / price);
    if (maxBuy < 1) {
      setGameMessage("Not enough balance to buy shares.");
      return;
    }
    // Buy one share for simplicity
    setBalances((bals) => {
      const cost = price;
      if (bals[selectedCrypto] < cost) {
        setGameMessage("Insufficient balance.");
        return bals;
      }
      return { ...bals, [selectedCrypto]: +(bals[selectedCrypto] - cost).toFixed(2) };
    });
    setPortfolio((p) => {
      const oldQty = p[symbol] || 0;
      return { ...p, [symbol]: oldQty + 1 };
    });
    setGameMessage(`Bought 1 share of ${symbol} for ${price.toFixed(2)} ${selectedCrypto}.`);
    playSound("win");
  }

  // --- Stock Market: sell shares ---
  function sellShares(symbol) {
    const price = stockPrices[symbol];
    if (!portfolio[symbol] || portfolio[symbol] < 1) {
      setGameMessage(`No shares of ${symbol} to sell.`);
      return;
    }
    // Sell one share for simplicity
    setPortfolio((p) => {
      const newQty = p[symbol] - 1;
      if (newQty <= 0) {
        const copy = { ...p };
        delete copy[symbol];
        return copy;
      }
      return { ...p, [symbol]: newQty };
    });
    setBalances((bals) => {
      return { ...bals, [selectedCrypto]: +(bals[selectedCrypto] + price).toFixed(2) };
    });
    setGameMessage(`Sold 1 share of ${symbol} for ${price.toFixed(2)} ${selectedCrypto}.`);
    playSound("win");
  }

  // --- Leaderboard update ---
  function updateLeaderboard(winAmount) {
    const date = new Date().toISOString();
    const entry = {
      crypto: selectedCrypto,
      amount: winAmount,
      date,
    };
    setLeaderboard((lb) => {
      const newLb = [...lb, entry]
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 10);
      return newLb;
    });
  }

  return (
    <div style={styles.app}>
      <h1 style={{ textAlign: "center" }}>Crypto Gambling Platform Demo</h1>

      {/* Crypto selector and balances */}
      <div style={styles.balances}>
        <div>
          <label>
            Select Crypto:{" "}
            <select
              value={selectedCrypto}
              onChange={(e) => setSelectedCrypto(e.target.value)}
            >
              {CRYPTOS.map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </label>
        </div>
        <div style={{ marginTop: 8 }}>
          <strong>Balance:</strong> {balances[selectedCrypto].toFixed(2)} {selectedCrypto}
        </div>
        <div style={{ marginTop: 4 }}>
          <button onClick={withdraw} style={styles.button}>
            Withdraw {selectedCrypto}
          </button>
        </div>
      </div>

      {/* Betting amount */}
      <div style={{ marginTop: 20 }}>
        <label>
          Bet Amount ({selectedCrypto}):{" "}
          <input
            type="number"
            min="1"
            max={balances[selectedCrypto]}
            value={betAmount}
            onChange={(e) => setBetAmount(Number(e.target.value))}
            style={{ width: 60 }}
          />
        </label>
      </div>

      {/* Games */}
      <div style={styles.gamesContainer}>
        {/* Dice Game */}
        <div style={styles.gameBox}>
          <h2>Dice Game</h2>
          <button onClick={playDice} style={styles.button}>
            Roll Dice
          </button>
          {diceRoll !== null && <p>Dice Roll: {diceRoll}</p>}
        </div>

        {/* Coin Flip */}
        <div style={styles.gameBox}>
          <h2>Coin Flip</h2>
          <label>
            <input
              type="radio"
              name="coinBet"
              value="heads"
              checked={coinBet === "heads"}
              onChange={() => setCoinBet("heads")}
            />
            Heads
          </label>{" "}
          <label>
            <input
              type="radio"
              name="coinBet"
              value="tails"
              checked={coinBet === "tails"}
              onChange={() => setCoinBet("tails")}
            />
            Tails
          </label>
          <br />
          <button onClick={playCoinFlip} style={styles.button}>
            Flip Coin
          </button>
          {coinFlip && <p>Result: {coinFlip}</p>}
        </div>

        {/* Slot Machine */}
        <div style={styles.gameBox}>
          <h2>Slot Machine</h2>
          <div style={{ fontSize: "2rem", minHeight: "2.5rem" }}>
            {slotResult ? slotResult.join(" ") : "🎰 🎰 🎰"}
          </div>
          <button
            onClick={playSlot}
            disabled={slotSpinning}
            style={{ ...styles.button, opacity: slotSpinning ? 0.5 : 1 }}
          >
            Spin Slots
          </button>
        </div>
      </div>

      {/* Game result message */}
      <div
        style={{
          marginTop: 20,
          padding: 10,
          backgroundColor: "#222",
          color: "#0f0",
          minHeight: 30,
          fontWeight: "bold",
        }}
      >
        {gameMessage}
      </div>

      {/* Stock Market Section */}
      <div style={{ marginTop: 40 }}>
        <h2>Stock Market Simulation</h2>
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "1px solid #666" }}>
              <th>Symbol</th>
              <th>Name</th>
              <th>Price ({selectedCrypto})</th>
              <th>Actions</th>
              <th>Your Shares</th>
            </tr>
          </thead>
          <tbody>
            {STOCKS.map(({ symbol, name }) => (
              <tr key={symbol} style={{ borderBottom: "1px solid #444" }}>
                <td>{symbol}</td>
                <td>{name}</td>
                <td>{stockPrices[symbol].toFixed(2)}</td>
                <td>
                  <button
                    onClick={() => buyShares(symbol)}
                    style={{ marginRight: 6 }}
                  >
                    Buy 1
                  </button>
                  <button onClick={() => sellShares(symbol)}>Sell 1</button>
                </td>
                <td>{portfolio[symbol] || 0}</td>
              </tr>
            ))}
          </tbody>
        </table>

        <div style={{ marginTop: 10 }}>
          <strong>Portfolio Value:</strong> {portfolioValue.toFixed(2)} {selectedCrypto}
        </div>
      </div>

      {/* Leaderboard */}
      <div style={{ marginTop: 40 }}>
        <h2>Leaderboard (Top Wins)</h2>
        {leaderboard.length === 0 ? (
          <p>No wins yet.</p>
        ) : (
          <table style={{ width: "100%", borderCollapse: "collapse" }}>
            <thead>
              <tr style={{ borderBottom: "1px solid #666" }}>
                <th>#</th>
                <th>Crypto</th>
                <th>Amount Won</th>
                <th>Date</th>
              </tr>
            </thead>
            <tbody>
              {leaderboard.map(({ crypto, amount, date }, i) => (
                <tr key={i} style={{ borderBottom: "1px solid #444" }}>
                  <td>{i + 1}</td>
                  <td>{crypto}</td>
                  <td>{amount.toFixed(2)}</td>
                  <td>{new Date(date).toLocaleString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>

      <footer style={{ marginTop: 50, textAlign: "center", color: "#666" }}>
        <small>Demo platform — no real crypto involved.</small>
      </footer>
    </div>
  );
}

const styles = {
  app: {
    maxWidth: 900,
    margin: "auto",
    padding: 20,
    fontFamily: "'Segoe UI',
